//----------------------
// <auto-generated>
//     Generated using the NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.3.0) (http://NJsonSchema.org)
// </auto-generated>
//----------------------


namespace MyNamespace
{
    #pragma warning disable // Disable all warnings

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public enum SetGameResult
    {

        [System.Runtime.Serialization.EnumMember(Value = @"win")]
        Win = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"lose")]
        Lose = 1,


        [System.Runtime.Serialization.EnumMember(Value = @"draw")]
        Draw = 2,


        [System.Runtime.Serialization.EnumMember(Value = @"dq")]
        Dq = 3,


    }

    /// <summary>
    /// Object containing metadata relevant to the entire event, such as the name and date of the event, game played, the format of the tournament (e.g. whether it was single-elim or double-elim), etc.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public partial class Event
    {
        /// <summary>
        /// String containing the title of this event. This is a required field.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("name")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.Never)]   
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Start date of the event. Should be provided in ISO 8601 format (YYYY-MM-DD).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("date")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        [System.Text.Json.Serialization.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset Date { get; set; }

        /// <summary>
        /// String representing the name of the game played at this event.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("gameName")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string GameName { get; set; }

        /// <summary>
        /// String representing the format of this tournament (e.g. single-elimination, double-elimination, etc.). This field should only be used to record format as it relates to the structure of the tournament (i.e. how matches are decided) and not format as it pertains to game-specific factors (e.g. whether it's a teams tournament, the ruleset in use, etc.). For commonly-used structures, use the following identifiers: 'single-elim' (Single elimination), 'double-elim' (Double elimination), 'round-robin' (Round robin).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("tournamentStructure")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string TournamentStructure { get; set; }

        /// <summary>
        /// Array of `Phase` objects containing information about each phase of this tournament. Useful for capturing complicated tournament structures, like round-robin pools leading into a double-elimination bracket (where different phases may have different structures). See the `Phase` definition for more information.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("phases")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public System.Collections.Generic.ICollection<Phase> Phases { get; set; }

        /// <summary>
        /// String representing the choice of ruleset.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("ruleset")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Ruleset { get; set; }

        /// <summary>
        /// String containing a external URL linking to the original source of this data (e.g. an external tournament website).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("originURL")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string OriginURL { get; set; }

        /// <summary>
        /// Integer containing the number of entrants in this tournament. If populated, this should be equal to the length of the `entrants` subarray of the root `Tournament` object.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("numberEntrants")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int NumberEntrants { get; set; }

        /// <summary>
        /// Object that can be used to store any other relevant event-related information not covered by the previously mentioned fields.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("other")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public object Other { get; set; }


    }

    /// <summary>
    /// Object representing an entrant in the tournament. Every unique entrant which appears in a set should have a corresponding `Entrant` object in the `entrants` subfield of `Tournament`.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public partial class Entrant
    {
        /// <summary>
        /// Unique string ID corresponding to this entrant. This ID can be an autogenerated identifier, some form of the player's tag, or the player's tag itself, as long as it is guaranteed that no two different entrants share the same `entrantID`. Entrants in `Set` objects are referenced by this ID. This is a required field.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrantID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.Never)]   
        [System.ComponentModel.DataAnnotations.Required]
        public string EntrantID { get; set; }

        /// <summary>
        /// String containing the entrant's ``tag; in other words, the name the entrant chooses when registering for the tournament, that appears in results, etc.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrantTag")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string EntrantTag { get; set; }

        /// <summary>
        /// Integer representing the initial seeding of this entrant. Larger seeds are worse seeds; 1 is the best possible seed.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("initialSeed")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public int InitialSeed { get; set; }

        /// <summary>
        /// Integer representing the final placing of this entrant.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("finalPlacement")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public int FinalPlacement { get; set; }

        /// <summary>
        /// List of personal data about players corresponding to this entrant (e.g. legal name, country, etc.). If this entrant corresponds to a single player, this will be a list of size one. If it is a team of several players, there will be one entry per player.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("personalInformation")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public System.Collections.Generic.ICollection<PersonalInformation> PersonalInformation { get; set; }

        /// <summary>
        /// Object that can be used to store any other relevant entrant-related information not covered by the previously mentioned fields.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("other")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public object Other { get; set; }


    }

    /// <summary>
    /// Object representing personal information (e.g. name, country) associated with an entrant. Subobject of `Entrant`.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public partial class PersonalInformation
    {
        /// <summary>
        /// String containing entrant's legal name.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("name")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Name { get; set; }

        /// <summary>
        /// String containing entrant's country.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("country")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Country { get; set; }

        /// <summary>
        /// String containing entrant's tag. Same as entrantTag if entrant is a single player.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("tag")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Tag { get; set; }

        /// <summary>
        /// String containing prefix for entrant's tag.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("prefix")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Prefix { get; set; }

        /// <summary>
        /// Object that can be used to store any other relevant personal entrant-related information not covered by the previously mentioned fields.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("other")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public object Other { get; set; }


    }

    /// <summary>
    /// Object representing a single set of the tournament.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public partial class Set
    {
        /// <summary>
        /// String containing a unique identifier for this set (i.e. no two sets in the event's `sets` array should have the same setID).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("setID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.Never)]   
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SetID { get; set; }

        /// <summary>
        /// The entrantID of the first player in this match.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant1ID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Entrant1ID { get; set; }

        /// <summary>
        /// The entrantID of the second player in this match.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant2ID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Entrant2ID { get; set; }

        /// <summary>
        /// String representing the status of this set. If populated, must take one of the following values: 'completed' (if the set has finished), 'started' (if the set is currently in progress), or 'pending' (if the set has yet to start).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("status")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public SetStatus Status { get; set; }

        /// <summary>
        /// String representing the result of entrant 1 in this match. If populated, must equal either 'win', 'lose', 'draw', or 'dq'. In the case of 'dq', the player disqualified should be assigned the 'dq' result and the other player should be assigned the 'win' result. (If both players are disqualified, both should be assigned 'dq').
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant1Result")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public SetGameResult Entrant1Result { get; set; }

        /// <summary>
        /// String representing the result of entrant 2 in this match. If populated, must equal either 'win', 'lose', 'draw', or 'dq'.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant2Result")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public SetGameResult Entrant2Result { get; set; }

        /// <summary>
        /// Integer representing the score of entrant 1 in this match.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant1Score")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public int Entrant1Score { get; set; }

        /// <summary>
        /// Integer representing the score of entrant 2 in this match.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant2Score")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public int Entrant2Score { get; set; }

        /// <summary>
        /// The setID of the set that entrant 1 will play next. For a single-elim or double-elim tournament, setting this allows one for reconstruction of the original bracket. If entrant 1 does not play another set (e.g. they have won or are knocked out), do not set this field.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant1NextSetID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Entrant1NextSetID { get; set; }

        /// <summary>
        /// The setID of the set that entrant 2 will play next. For a double-elim tournament, setting this allows one for reconstruction of the original bracket. If entrant 2 does not play another set, do not set this field.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant2NextSetID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Entrant2NextSetID { get; set; }

        /// <summary>
        /// The setID of the set that entrant 1 played right before this set. If this is entrant 1's first set, do not set this field.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant1PrevSetID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Entrant1PrevSetID { get; set; }

        /// <summary>
        /// The setID of the set that entrant 2 played right before this set. If this is entrant 2's first set, do not set this field.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant2PrevSetID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Entrant2PrevSetID { get; set; }

        /// <summary>
        /// String representing format specific to this set (e.g. whether it was best of 3 or best of 5).
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("setFormat")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string SetFormat { get; set; }

        /// <summary>
        /// String representing the `phase' of this specific set. It is up to the user's discretion to decide what precisely a phase means. For tournaments with multiple phases / levels (e.g. pools, top 64, top 8), it is convenient to record this information here.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("phaseID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string PhaseID { get; set; }

        /// <summary>
        /// String representing the `round' in the bracket of this specific set (for example, "Winner's Round 1" or "Semifinals"). It is up to the user's discretion to decide what precisely a round means and how to record it.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("roundID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string RoundID { get; set; }

        /// <summary>
        /// Array of `Game` objects containing information about each game of this set. It is recommended (but not required) that this array records the games in chronological order. See the `Game` definition for more information.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("games")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public System.Collections.Generic.ICollection<Game> Games { get; set; }

        /// <summary>
        /// Object that can be used to store any other relevant set-related information not covered by the previously mentioned fields.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("other")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public object Other { get; set; }


    }

    /// <summary>
    /// Object representing a single game of a set.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public partial class Game
    {
        /// <summary>
        /// Integer representing the number (in chronological order) of this game. The `gameNumber`s of the games of a set should be unique and span a consecutive range of integers starting at 1.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("gameNumber")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.Never)]   
        [System.ComponentModel.DataAnnotations.Range(1, int.MaxValue)]
        public int GameNumber { get; set; }

        /// <summary>
        /// Array of strings representing the character(s) played by entrant 1 in this game. If entrant 1 only plays a single character in this game (most cases), this field should contain an array containing a single string (entrant 1's character). In team games or games where each entrant can choose a selection of different characters, you should record these characters as separate elements of this field.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant1Characters")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public System.Collections.Generic.ICollection<string> Entrant1Characters { get; set; }

        /// <summary>
        /// Array of strings representing the character(s) played by entrant 2 in this game. See also `entrant1Characters`.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant2Characters")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public System.Collections.Generic.ICollection<object> Entrant2Characters { get; set; }

        /// <summary>
        /// String representing the stage this game was played on.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("stage")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string Stage { get; set; }

        /// <summary>
        /// String representing the result of entrant 1.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant1Result")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public SetGameResult Entrant1Result { get; set; }

        /// <summary>
        /// String representing the result of entrant 2.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrant2Result")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public SetGameResult Entrant2Result { get; set; }

        /// <summary>
        /// Object that can be used to store any other relevant game-related information not covered by the previously mentioned fields.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("other")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public object Other { get; set; }


    }

    /// <summary>
    /// Object representing a single phase of a tournament (e.g. pools, top 64, etc.) Useful for recording tournaments with complex structures (e.g. round-robin pools into a double-elimination bracket). See the `phases` field in `Event` for more information.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public partial class Phase
    {
        /// <summary>
        /// Unique string ID corresponding to this phase.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("phaseID")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.Never)]   
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PhaseID { get; set; }

        /// <summary>
        /// String representing the format of this tournament in this phase (e.g. single-elimination, double-elimination, etc.). See the `tournamentStructure` field in `Event` for more information.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("phaseStructure")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public string PhaseStructure { get; set; }

        /// <summary>
        /// Object that can be used to store any other relevant phase-related information not covered by the previously mentioned fields.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("other")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        public object Other { get; set; }


    }

    /// <summary>
    /// Root object: every OpenBracketFormat file should consist of exactly one `Tournament` object.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public partial class Sample
    {
        /// <summary>
        /// Object that contains metadata relevant to the entire tournament -- e.g. name and date of the event, tournament format, etc. See the `Event` definition for more information.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("event")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.Never)]   
        [System.ComponentModel.DataAnnotations.Required]
        public Event Event { get; set; } = new Event();

        /// <summary>
        /// Unordered array of all sets that took place during this tournament. See the `Set` definition for more information.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("sets")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.Never)]   
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Set> Sets { get; set; } = new System.Collections.ObjectModel.Collection<Set>();

        /// <summary>
        /// Unordered array of all entrants in the tournament. See the `Entrant` definition for more information.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("entrants")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.Never)]   
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Entrant> Entrants { get; set; } = new System.Collections.ObjectModel.Collection<Entrant>();

        /// <summary>
        /// Stores the version of the Open Bracket Format specification that this file was generated in accordance with. It is highly recommended (but not required) to include this field -- if this field is not set, the default assumption will be that the file was generated with the most recent version of OBF. The current version of the OBF format (what you are reading) is `v0.2`.
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("version")]

        [System.Text.Json.Serialization.JsonIgnore(Condition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingDefault)]   
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public SampleVersion Version { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public enum SetStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"completed")]
        Completed = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"started")]
        Started = 1,


        [System.Runtime.Serialization.EnumMember(Value = @"pending")]
        Pending = 2,


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    public enum SampleVersion
    {

        [System.Runtime.Serialization.EnumMember(Value = @"v0.1")]
        V0_1 = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"v0.2")]
        V0_2 = 1,


        [System.Runtime.Serialization.EnumMember(Value = @"v1.0")]
        V1_0 = 2,


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.8.0.0 (Newtonsoft.Json v13.0.3.0)")]
    internal class DateFormatConverter : System.Text.Json.Serialization.JsonConverter<System.DateTimeOffset>
    {
        public override System.DateTimeOffset Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
        {
            var dateTime = reader.GetString();
            if (dateTime == null)
            {
                throw new System.Text.Json.JsonException("Unexpected JsonTokenType.Null");
            }

            return System.DateTimeOffset.Parse(dateTime);
        }

        public override void Write(System.Text.Json.Utf8JsonWriter writer, System.DateTimeOffset value, System.Text.Json.JsonSerializerOptions options)
        {
            writer.WriteStringValue(value.ToString("yyyy-MM-dd"));
        }
    }
}